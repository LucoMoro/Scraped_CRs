/*Make up better class names.

JavaGenerator -> SourceProcessor
GeneratorDeltaVisitor -> SourceChangeHandler
NonJavaFileBundle -> SourceFileData

Change-Id:Idaacbef34007a1af730500d8009241683ee9e37b*/




//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/AidlGenerator.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/AidlProcessor.java
similarity index 95%
rename from eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/AidlGenerator.java
rename to eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/AidlProcessor.java
//Synthetic comment -- index a3c587f..a4bcbed 100644

//Synthetic comment -- @@ -47,10 +47,10 @@
import java.util.regex.Pattern;

/**
 * A {@link SourceProcessor} for aidl files.
*
*/
public class AidlProcessor extends SourceProcessor {

private static final String PROPERTY_COMPILE_AIDL = "compileAidl"; //$NON-NLS-1$

//Synthetic comment -- @@ -75,7 +75,7 @@
//          "^\\s*interface\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?:\\{.*)?$");


    public AidlProcessor(IJavaProject javaProject, IFolder genFolder) {
super(javaProject, genFolder);
}

//Synthetic comment -- @@ -136,16 +136,16 @@
String osSourcePath = sourcePath.toOSString();

// look if we already know the output
            SourceFileData data = getFileData(sourceFile);
            if (data == null) {
IFile javaFile = getAidlOutputFile(sourceFile, true /*createFolders*/, monitor);
                data = new SourceFileData(sourceFile, javaFile);
                addData(data);
}

// finish to set the command line.
command[index] = osSourcePath;
            command[index + 1] = data.getOutput().getLocation().toOSString();

// launch the process
if (execAidl(builder, project, command, sourceFile, verbose) == false) {
//Synthetic comment -- @@ -159,12 +159,12 @@
@Override
protected void loadOutputAndDependencies() {
IProgressMonitor monitor = new NullProgressMonitor();
        Collection<SourceFileData> dataList = getAllFileData();
        for (SourceFileData data : dataList) {
try {
                IFile javaFile = getAidlOutputFile(data.getSourceFile(),
false /*createFolders*/, monitor);
                data.setOutputFile(javaFile);
} catch (CoreException e) {
// ignore, we're not asking to create the folder so this won't happen anyway.
}








//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/RenderScriptGenerator.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/RenderScriptProcessor.java
similarity index 91%
rename from eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/RenderScriptGenerator.java
rename to eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/RenderScriptProcessor.java
//Synthetic comment -- index 458f1b5..28ba66e 100644

//Synthetic comment -- @@ -51,10 +51,10 @@
import java.util.regex.Pattern;

/**
 * A {@link SourceProcessor} for RenderScript files.
*
*/
public class RenderScriptProcessor extends SourceProcessor {

private static final String PROPERTY_COMPILE_RS = "compileRenderScript"; //$NON-NLS-1$

//Synthetic comment -- @@ -63,7 +63,7 @@
*/
private static Pattern sLlvmPattern1 = Pattern.compile("^(.+?):(\\d+):(\\d+):\\s(.+)$"); //$NON-NLS-1$

    private static class RsChangeHandler extends SourceChangeHandler {

@Override
public boolean handleGeneratedFile(IFile file, int kind) {
//Synthetic comment -- @@ -73,14 +73,14 @@
AndroidConstants.EXT_DEP.equalsIgnoreCase(file.getFileExtension())) {
// This looks to be an extension file.
// For futureproofness let's make sure this dependency file was generated by
                // this processor even if it's the only processor using them for now.

// look for the original file.
// We know we are in the gen folder, so make a path to the dependency file
// relative to the gen folder. Convert this into a Renderscript source file,
// and look to see if this file exists.
                SourceProcessor processor = getProcessor();
                IFolder genFolder = processor.getGenFolder();
IPath relative = file.getFullPath().makeRelativeTo(genFolder.getFullPath());
// remove the file name segment
relative = relative.removeLastSegments(1);
//Synthetic comment -- @@ -90,7 +90,7 @@

// now look for a match in the source folders.
List<IPath> sourceFolders = BaseProjectHelper.getSourceClasspaths(
                        processor.getJavaProject());
IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();

for (IPath sourceFolderPath : sourceFolders) {
//Synthetic comment -- @@ -98,8 +98,8 @@
// we don't look in the 'gen' source folder as there will be no source in there.
if (sourceFolder.exists() && sourceFolder.equals(genFolder) == false) {
IFile sourceFile = sourceFolder.getFile(relative);
                        SourceFileData data = processor.getFileData(sourceFile);
                        if (data != null) {
addFileToCompile(sourceFile);
return true;
}
//Synthetic comment -- @@ -116,8 +116,8 @@
}
}

    public RenderScriptProcessor(IJavaProject javaProject, IFolder genFolder) {
        super(javaProject, genFolder, new RsChangeHandler());
}

@Override
//Synthetic comment -- @@ -185,9 +185,9 @@

// Remove the RS error markers from the source file and the dependencies
builder.removeMarkersFromFile(sourceFile, AndroidConstants.MARKER_RENDERSCRIPT);
            SourceFileData data = getFileData(sourceFile);
            if (data != null) {
                for (IFile dep : data.getDependencyFiles()) {
builder.removeMarkersFromFile(dep, AndroidConstants.MARKER_RENDERSCRIPT);
}
}
//Synthetic comment -- @@ -358,7 +358,7 @@


@Override
    protected void doRemoveFiles(SourceFileData bundle) throws CoreException {
// call the super implementation, it will remove the output files
super.doRemoveFiles(bundle);

//Synthetic comment -- @@ -371,11 +371,11 @@

@Override
protected void loadOutputAndDependencies() {
        Collection<SourceFileData> dataList = getAllFileData();
        for (SourceFileData data : dataList) {
// parse the dependency file. If this fails, force compilation of the file.
            if (parseDependencyFileFor(data.getSourceFile()) == false) {
                addFileToCompile(data.getSourceFile());
}
}
}
//Synthetic comment -- @@ -384,12 +384,12 @@
IFile depFile = getDependencyFileFor(sourceFile);
File f = depFile.getLocation().toFile();
if (f.exists()) {
            SourceFileData data = getFileData(sourceFile);
            if (data == null) {
                data = new SourceFileData(sourceFile);
                addData(data);
}
            parseDependencyFile(data, f);
return true;
}

//Synthetic comment -- @@ -420,12 +420,12 @@
}

/**
     * Parses the given dependency file and fills the given {@link SourceFileData} with it.
*
     * @param data the bundle to fill.
* @param file the dependency file
*/
    private void parseDependencyFile(SourceFileData data, File dependencyFile) {
//contents = file.getContents();
String content = AdtPlugin.readFile(dependencyFile);

//Synthetic comment -- @@ -460,8 +460,8 @@
fillList(outputs, outputFiles);
fillList(dependencies, dependencyFiles);

        data.setOutputFiles(outputFiles);
        data.setDependencyFiles(dependencyFiles);
}

private void fillList(String[] paths, List<IFile> list) {








//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/GeneratorDeltaVisitor.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceChangeHandler.java
similarity index 76%
rename from eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/GeneratorDeltaVisitor.java
rename to eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceChangeHandler.java
//Synthetic comment -- index 01cd13e..537dd61 100644

//Synthetic comment -- @@ -19,28 +19,25 @@
import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResourceDelta;

import java.util.HashSet;
import java.util.Set;

/**
 * Base source change handler for the {@link SourceProcessor} classes.
*
 * It can be used as is, as long as the matching {@link SourceProcessor} properly implements
 * its abstract methods, and the processor does not output resource files,
* or can be extended to provide custom implementation for:
* {@link #handleSourceFile(IFile, int)}
* {@link #handleGeneratedFile(IFile, int)}
* {@link #handleResourceFile(IFile, int)}
* {@link #filterResourceFolder(IContainer)}
*
*/
public class SourceChangeHandler {

    private SourceProcessor mProcessor;

/** List of source files found that are modified or new. */
private final Set<IFile> mToCompile = new HashSet<IFile>();
//Synthetic comment -- @@ -50,7 +47,7 @@

public boolean handleGeneratedFile(IFile file, int kind) {
if (kind == IResourceDelta.REMOVED || kind == IResourceDelta.CHANGED) {
            IFile sourceFile = mProcessor.isOutput(file);
if (sourceFile != null) {
mToCompile.add(sourceFile);
return true;
//Synthetic comment -- @@ -61,8 +58,8 @@
}

public void handleSourceFile(IFile file, int kind) {
        // first the file itself if this is a match for the processor's extension
        if (mProcessor.getExtension().equals(file.getFileExtension())) {
if (kind == IResourceDelta.REMOVED) {
mRemoved.add(file);
} else {
//Synthetic comment -- @@ -72,7 +69,7 @@

// now the dependencies. In all case we compile the files that depend on the
// added/changed/removed file.
        mToCompile.addAll(mProcessor.isDependency(file));
}

public void handleResourceFile(IFile file, int kind) {
//Synthetic comment -- @@ -111,11 +108,11 @@
mRemoved.clear();
}

    protected SourceProcessor getProcessor() {
        return mProcessor;
}

    void init(SourceProcessor processor) {
        mProcessor = processor;
}
}








//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/NonJavaFileBundle.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceFileData.java
similarity index 72%
rename from eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/NonJavaFileBundle.java
rename to eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceFileData.java
//Synthetic comment -- index fe071fb..1b6d3fb 100644

//Synthetic comment -- @@ -23,21 +23,21 @@
import java.util.List;

/**
 * Data for Android-specific source files. It contains a list of output files and a list
* of dependencies.
* The source file itself is a implied dependency and is not meant to be in the dependency list.
*/
public class SourceFileData {

private final IFile mSourceFile;
private final List<IFile> mOutputFiles = new ArrayList<IFile>();
private final List<IFile> mDependencyFiles = new ArrayList<IFile>();

    public SourceFileData(IFile sourceFile) {
this(sourceFile, null, null);
}

    SourceFileData(IFile sourceFile,
List<IFile> outputFiles, List<IFile> dependencyFiles) {
mSourceFile = sourceFile;
if (outputFiles != null) {
//Synthetic comment -- @@ -48,40 +48,56 @@
}
}

    SourceFileData(IFile sourceFile, IFile outputFile) {
mSourceFile = sourceFile;
if (outputFile != null) {
mOutputFiles.add(outputFile);
}
}

    /**
     * Returns the source file as an {@link IFile}
     */
public IFile getSourceFile() {
return mSourceFile;
}

    /**
     * Returns whether the given file is a dependency for this source file.
     * <p/>Note that the source file itself is not tested against. Therefore if
     * {@code file.equals(getSourceFile()} returns {@code true}, this method will return
     * {@code false}.
     * @param file the file to check against
     * @return true if the given file is a dependency for this source file.
     */
public boolean dependsOn(IFile file) {
return mDependencyFiles.contains(file);
}

    /**
     * Returns whether the given file is an ouput of this source file.
     * @param file the file to test.
     * @return true if the file is an output file.
     */
public boolean generated(IFile file) {
return mOutputFiles.contains(file);
}

    void setOutputFiles(List<IFile> outputFiles) {
mOutputFiles.clear();
if (outputFiles != null) {
mOutputFiles.addAll(outputFiles);
}
}

    void setOutputFile(IFile outputFile) {
mOutputFiles.clear();
if (outputFile != null) {
mOutputFiles.add(outputFile);
}
}

    void setDependencyFiles(List<IFile> depFiles) {
mDependencyFiles.clear();
if (depFiles != null) {
mDependencyFiles.addAll(depFiles);








//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/JavaGenerator.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceProcessor.java
similarity index 86%
rename from eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/JavaGenerator.java
rename to eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/SourceProcessor.java
//Synthetic comment -- index 9e38031..d08cdc5 100644

//Synthetic comment -- @@ -45,22 +45,19 @@
* It provides management for modified source file list, deleted source file list, reconciliation
* of previous lists, storing the current state of the build.
*
*/
public abstract class SourceProcessor {

public final static int COMPILE_STATUS_NONE = 0;
public final static int COMPILE_STATUS_CODE = 0x1;
public final static int COMPILE_STATUS_RES = 0x2;

/** List of all source files, their dependencies, and their output. */
    private final Map<IFile, SourceFileData> mFiles = new HashMap<IFile, SourceFileData>();

private final IJavaProject mJavaProject;
private final IFolder mGenFolder;
    private final SourceChangeHandler mDeltaVisitor;

/** List of source files pending compilation at the next build */
private final List<IFile> mToCompile = new ArrayList<IFile>();
//Synthetic comment -- @@ -68,8 +65,8 @@
/** List of removed source files pending cleaning at the next build. */
private final List<IFile> mRemoved = new ArrayList<IFile>();

    protected SourceProcessor(IJavaProject javaProject, IFolder genFolder,
            SourceChangeHandler deltaVisitor) {
mJavaProject = javaProject;
mGenFolder = genFolder;
mDeltaVisitor = deltaVisitor;
//Synthetic comment -- @@ -94,21 +91,21 @@
}
}

    protected SourceProcessor(IJavaProject javaProject, IFolder genFolder) {
        this(javaProject, genFolder, new SourceChangeHandler());
}


/**
     * Returns whether the given file is an output of this processor by return the source
* file that generated it.
* @param file the file to test.
* @return the source file that generated the given file or null.
*/
IFile isOutput(IFile file) {
        for (SourceFileData data : mFiles.values()) {
            if (data.generated(file)) {
                return data.getSourceFile();
}
}

//Synthetic comment -- @@ -124,28 +121,28 @@
*/
List<IFile> isDependency(IFile file) {
ArrayList<IFile> files = new ArrayList<IFile>();
        for (SourceFileData data : mFiles.values()) {
            if (data.dependsOn(file)) {
                files.add(data.getSourceFile());
}
}

return files;
}

    void addData(SourceFileData data) {
        mFiles.put(data.getSourceFile(), data);
}

    SourceFileData getFileData(IFile file) {
return mFiles.get(file);
}

    Collection<SourceFileData> getAllFileData() {
return mFiles.values();
}

    public final SourceChangeHandler getChangeHandler() {
return mDeltaVisitor;
}

//Synthetic comment -- @@ -190,7 +187,7 @@
}

/**
     * Returns the extension of the source files handled by this processor.
* @return
*/
protected abstract String getExtension();
//Synthetic comment -- @@ -231,13 +228,13 @@
// Remove the files created from source files that have been removed.
for (IFile sourceFile : mRemoved) {
// look if we already know the output
            SourceFileData data = getFileData(sourceFile);
            if (data != null) {
                doRemoveFiles(data);
}
}

        // remove the associated file data.
for (IFile removedFile : mRemoved) {
mFiles.remove(removedFile);
}
//Synthetic comment -- @@ -261,13 +258,13 @@
/**
* Returns the type of compilation. It can be any of (in combination too):
* <p/>
     * {@link #COMPILE_STATUS_CODE} means this processor created source code files.
     * {@link #COMPILE_STATUS_RES} means this process created resources.
*/
protected abstract int getCompilationType();

    protected void doRemoveFiles(SourceFileData data) throws CoreException {
        List<IFile> outputFiles = data.getOutputFiles();
for (IFile outputFile : outputFiles) {
if (outputFile.exists()) {
outputFile.getLocation().toFile().delete();
//Synthetic comment -- @@ -346,10 +343,10 @@
switch (r.getType()) {
case IResource.FILE:
// if this a file, check that the file actually exist
                       // and that it's the type of of file that's used in this processor
if (r.exists() &&
getExtension().equalsIgnoreCase(r.getFileExtension())) {
                           mFiles.put((IFile) r, new SourceFileData((IFile) r));
}
break;
case IResource.FOLDER:
//Synthetic comment -- @@ -373,7 +370,7 @@
* delta visitor
* @param visitor the delta visitor.
*/
    private void mergeFileModifications(SourceChangeHandler visitor) {
Set<IFile> toRemove = visitor.getRemovedFiles();
Set<IFile> toCompile = visitor.getFilesToCompile();









//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/builders/PreCompilerBuilder.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/builders/PreCompilerBuilder.java
//Synthetic comment -- index 8cd7aa4..5886cff 100644

//Synthetic comment -- @@ -19,10 +19,10 @@
import com.android.ide.eclipse.adt.AdtPlugin;
import com.android.ide.eclipse.adt.AndroidConstants;
import com.android.ide.eclipse.adt.internal.build.AaptParser;
import com.android.ide.eclipse.adt.internal.build.AidlProcessor;
import com.android.ide.eclipse.adt.internal.build.SourceProcessor;
import com.android.ide.eclipse.adt.internal.build.Messages;
import com.android.ide.eclipse.adt.internal.build.RenderScriptProcessor;
import com.android.ide.eclipse.adt.internal.preferences.AdtPrefs;
import com.android.ide.eclipse.adt.internal.preferences.AdtPrefs.BuildVerbosity;
import com.android.ide.eclipse.adt.internal.project.AndroidManifestHelper;
//Synthetic comment -- @@ -85,7 +85,7 @@
*/
private boolean mMustCompileResources = false;

    private final List<SourceProcessor> mProcessors = new ArrayList<SourceProcessor>();

/** cache of the java package defined in the manifest */
private String mManifestPackage;
//Synthetic comment -- @@ -232,8 +232,8 @@

mMustCompileResources = true;

                for (SourceProcessor processor : mProcessors) {
                    processor.prepareFullBuild(project);
}
} else {
AdtPlugin.printBuildToConsole(BuildVerbosity.VERBOSE, project,
//Synthetic comment -- @@ -247,17 +247,17 @@
if (delta == null) {
mMustCompileResources = true;

                    for (SourceProcessor processor : mProcessors) {
                        processor.prepareFullBuild(project);
}
} else {
                    dv = new PreCompilerDeltaVisitor(this, sourceFolderPathList, mProcessors);
delta.accept(dv);

// record the state
mMustCompileResources |= dv.getCompileResources();
                    for (SourceProcessor processor : mProcessors) {
                        processor.doneVisiting(project);
}

// get the java package from the visitor
//Synthetic comment -- @@ -461,31 +461,31 @@
// force a clean
doClean(project, monitor);
mMustCompileResources = true;
                for (SourceProcessor processor : mProcessors) {
                    processor.prepareFullBuild(project);
}

saveProjectBooleanProperty(PROPERTY_COMPILE_RESOURCES , mMustCompileResources);
}

            // run the source processors
            int processorStatus = SourceProcessor.COMPILE_STATUS_NONE;
            for (SourceProcessor processor : mProcessors) {
try {
                    processorStatus |= processor.compileFiles(this,
project, projectTarget, sourceFolderPathList, monitor);
} catch (Throwable t) {
}
}

            // if a processor created some resources file, force recompilation of the resources.
            if ((processorStatus & SourceProcessor.COMPILE_STATUS_RES) != 0) {
mMustCompileResources = true;
// save the current state before attempting the compilation
saveProjectBooleanProperty(PROPERTY_COMPILE_RESOURCES , mMustCompileResources);
}

            // handle the resources, after the processors are run since some (renderscript)
// generate resources.
boolean compiledTheResources = mMustCompileResources;
if (mMustCompileResources) {
//Synthetic comment -- @@ -493,7 +493,7 @@
saveProjectBooleanProperty(PROPERTY_COMPILE_RESOURCES , false);
}

            if (processorStatus == SourceProcessor.COMPILE_STATUS_NONE &&
compiledTheResources == false) {
AdtPlugin.printBuildToConsole(BuildVerbosity.VERBOSE, project,
Messages.Nothing_To_Compile);
//Synthetic comment -- @@ -552,11 +552,11 @@

IJavaProject javaProject = JavaCore.create(project);

        // load the source processors
        SourceProcessor aidlProcessor = new AidlProcessor(javaProject, mGenFolder);
        mProcessors.add(aidlProcessor);
        SourceProcessor renderScriptProcessor = new RenderScriptProcessor(javaProject, mGenFolder);
        mProcessors.add(renderScriptProcessor);

mDerivedProgressMonitor = new DerivedProgressMonitor(mGenFolder);
}








//Synthetic comment -- diff --git a/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/builders/PreCompilerDeltaVisitor.java b/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/build/builders/PreCompilerDeltaVisitor.java
//Synthetic comment -- index f7365e5..5379622 100644

//Synthetic comment -- @@ -18,8 +18,8 @@

import com.android.ide.eclipse.adt.AdtPlugin;
import com.android.ide.eclipse.adt.AndroidConstants;
import com.android.ide.eclipse.adt.internal.build.SourceChangeHandler;
import com.android.ide.eclipse.adt.internal.build.SourceProcessor;
import com.android.ide.eclipse.adt.internal.build.Messages;
import com.android.ide.eclipse.adt.internal.build.builders.BaseBuilder.BaseDeltaVisitor;
import com.android.ide.eclipse.adt.internal.preferences.AdtPrefs.BuildVerbosity;
//Synthetic comment -- @@ -91,21 +91,21 @@
private List<IPath> mSourceFolders;
private boolean mIsGenSourceFolder = false;

    private final List<SourceChangeHandler> mSourceChangeHandlers =
        new ArrayList<SourceChangeHandler>();
private IWorkspaceRoot mRoot;



public PreCompilerDeltaVisitor(BaseBuilder builder, List<IPath> sourceFolders,
            List<SourceProcessor> processors) {
super(builder);
mSourceFolders = sourceFolders;
mRoot = ResourcesPlugin.getWorkspace().getRoot();

        for (SourceProcessor processor : processors) {
            SourceChangeHandler handler = processor.getChangeHandler();
            mSourceChangeHandlers.add(handler);
}
}

//Synthetic comment -- @@ -272,11 +272,11 @@
// we want a warning
outputWarning = true;
} else {
                    // look to see if this file was generated by a processor.
                    for (SourceChangeHandler dv : mSourceChangeHandlers) {
if (dv.handleGeneratedFile(file, kind)) {
outputWarning = true;
                            break; // there shouldn't be 2 processors that handle the same file.
}
}
}
//Synthetic comment -- @@ -295,7 +295,7 @@
}
} else {
// this is another source folder.
                for (SourceChangeHandler dv : mSourceChangeHandlers) {
dv.handleSourceFile(file, kind);
}
}
//Synthetic comment -- @@ -342,7 +342,7 @@
mBuilder.getProject(), message);
}

            for (SourceChangeHandler dv : mSourceChangeHandlers) {
dv.handleResourceFile((IFile)resource, kind);
}








