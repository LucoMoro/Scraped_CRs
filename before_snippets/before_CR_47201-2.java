
//<Beginning of snippet n. 0>



package com.android.ant;

import com.android.sdklib.io.FileOp;

import org.apache.tools.ant.BuildException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
* Task to execute aidl.
private class AidlProcessor implements SourceProcessor {

@Override
        public String getSourceFileExtension() {
            return "aidl";
}

@Override

//<End of snippet n. 0>










//<Beginning of snippet n. 1>


}

interface SourceProcessor {
        String getSourceFileExtension();
void process(String filePath, String sourceFolder,
List<String> sourceFolders, Project taskProject);
void displayMessage(DisplayType type, int count);

Project taskProject = getProject();

        String extension = processor.getSourceFileExtension();

// build a list of all the source folders
ArrayList<String> sourceFolders = new ArrayList<String>();
}
}

// gather all the source files from all the source folders.
Map<String, String> sourceFiles = getFilesByNameEntryFilter(sourceFolders,
                "**/*." + extension);
if (sourceFiles.size() > 0) {
processor.displayMessage(DisplayType.FOUND, sourceFiles.size());
}
// The gen folder may contain other dependency files not generated by this particular
// processor.
// We only care if the first pre-rep is of the right extension.
            if (sourceFilePath.toLowerCase(Locale.US).endsWith("." + extension)) {
// remove from the list of sourceFiles to mark as "processed" (but not compiled
// yet, that'll be done by adding it to toCompile)
String sourceFolder = sourceFiles.get(sourceFilePath);
* @param filter the filter for the files. Typically a glob.
* @return a map of (file, folder)
*/
    private Map<String, String> getFilesByNameEntryFilter(List<String> folders, String filter) {
Map<String, String> sourceFiles = new HashMap<String, String>();

for (String folder : folders) {
            Iterator<?> iterator = getFilesByNameEntryFilter(folder, filter);

while (iterator.hasNext()) {
sourceFiles.put(iterator.next().toString(), folder);
* @param filter the filter for the files. Typically a glob.
* @return an iterator.
*/
    private Iterator<?> getFilesByNameEntryFilter(String folder, String filter) {
Project taskProject = getProject();

// create a fileset to find all the files in the folder
FileSet fs = new FileSet();
fs.setProject(taskProject);
fs.setDir(new File(folder));
        NameEntry include = fs.createInclude();
        include.setName(filter);

// loop through the results of the file set
return fs.iterator();

//<End of snippet n. 1>










//<Beginning of snippet n. 2>



package com.android.ant;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecTask;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
* Task to execute renderscript.
*/
public class RenderScriptTask extends MultiFilesTask {

private String mExecutable;
private Path mIncludePath;
private String mGenFolder;
}

@Override
        public String getSourceFileExtension() {
            return "rs";
}

@Override

//<End of snippet n. 2>










//<Beginning of snippet n. 3>


public static final String EXT_AIDL = "aidl"; //$NON-NLS-1$
/** Extension of Renderscript files, i.e. "rs" */
public static final String EXT_RS = "rs"; //$NON-NLS-1$
/** Extension of dependency files, i.e. "d" */
public static final String EXT_DEP = "d"; //$NON-NLS-1$
/** Extension of native libraries, i.e. "so" */
public static final String DOT_AIDL = DOT + EXT_AIDL;
/** Dot-Extension of renderscript files, i.e. ".rs" */
public static final String DOT_RS = DOT + EXT_RS;
/** Dot-Extension of dependency files, i.e. ".d" */
public static final String DOT_DEP = DOT + EXT_DEP;
/** Dot-Extension of dex files, i.e. ".dex" */

//<End of snippet n. 3>










//<Beginning of snippet n. 4>


import static com.android.SdkConstants.DOT_DEP;
import static com.android.SdkConstants.DOT_JAVA;
import static com.android.SdkConstants.DOT_RS;

import com.android.SdkConstants;
import com.android.ide.eclipse.adt.internal.build.builders.PostCompilerBuilder;
public final static String RE_AIDL_EXT = "\\" + DOT_AIDL + "$"; //$NON-NLS-1$ //$NON-NLS-2$
/** Regexp for rs extension, i.e. "\.rs$" */
public final static String RE_RS_EXT = "\\" + DOT_RS + "$"; //$NON-NLS-1$ //$NON-NLS-2$
/** Regexp for .d extension, i.e. "\.d$" */
public final static String RE_DEP_EXT = "\\" + DOT_DEP + "$"; //$NON-NLS-1$ //$NON-NLS-2$


//<End of snippet n. 4>










//<Beginning of snippet n. 5>


import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

*/
private static Pattern sAidlPattern1 = Pattern.compile("^(.+?):(\\d+):?\\s(.+)$"); //$NON-NLS-1$


private enum AidlType {
UNKNOWN, INTERFACE, PARCELABLE;
}

@Override
    protected String getExtension() {
        return SdkConstants.EXT_AIDL;
}

@Override

//<End of snippet n. 5>










//<Beginning of snippet n. 6>


import com.android.ide.eclipse.adt.internal.sdk.Sdk;
import com.android.resources.ResourceFolderType;
import com.android.sdklib.IAndroidTarget;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

*/
private static Pattern sLlvmPattern1 = Pattern.compile("^(.+?):(\\d+):(\\d+):\\s(.+)$"); //$NON-NLS-1$

private static class RsChangeHandler extends SourceChangeHandler {

@Override
// remove the file name segment
relative = relative.removeLastSegments(1);
// add the file name of a Renderscript file.
                relative = relative.append(file.getName().replaceAll(AdtConstants.RE_DEP_EXT,
                        SdkConstants.DOT_RS));

                // now look for a match in the source folders.
                List<IPath> sourceFolders = BaseProjectHelper.getSourceClasspaths(
                        processor.getJavaProject());
                IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();

                for (IPath sourceFolderPath : sourceFolders) {
                    IFolder sourceFolder = root.getFolder(sourceFolderPath);
                    // we don't look in the 'gen' source folder as there will be no source in there.
                    if (sourceFolder.exists() && sourceFolder.equals(genFolder) == false) {
                        IFile sourceFile = sourceFolder.getFile(relative);
                        SourceFileData data = processor.getFileData(sourceFile);
                        if (data != null) {
                            addFileToCompile(sourceFile);
                            return true;
                        }
}
}
}

            return r;
}

@Override
}

@Override
    protected String getExtension() {
        return SdkConstants.EXT_RS;
}

@Override

//<End of snippet n. 6>










//<Beginning of snippet n. 7>



public void handleSourceFile(IFile file, int kind) {
// first the file itself if this is a match for the processor's extension
        if (mProcessor.getExtension().equals(file.getFileExtension())) {
if (kind == IResourceDelta.REMOVED) {
mRemoved.add(file);
} else {

//<End of snippet n. 7>










//<Beginning of snippet n. 8>


import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

* Returns the extension of the source files handled by this processor.
* @return
*/
    protected abstract String getExtension();

protected abstract String getSavePropertyName();

// if this a file, check that the file actually exist
// and that it's the type of of file that's used in this processor
if (r.exists() &&
                               getExtension().equalsIgnoreCase(r.getFileExtension())) {
mFiles.put((IFile) r, new SourceFileData((IFile) r));
}
break;

//<End of snippet n. 8>








