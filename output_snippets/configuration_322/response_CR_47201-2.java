//<Beginning of snippet n. 0>


package com.android.ant;

import com.android.sdklib.io.FileOp;

import org.apache.tools.ant.BuildException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
* Task to execute aidl.
*/
private class AidlProcessor implements SourceProcessor {

    @Override
    public String getSourceFileExtension() {
        return "aidl";
    }

    @Override
    public void process(String filePath, String sourceFolder, List<String> sourceFolders, Project taskProject) {
        // Process logic for AIDL files
    }

    @Override
    public void displayMessage(DisplayType type, int count) {
        // Display message logic
    }
}

//<End of snippet n. 0>

//<Beginning of snippet n. 1>

interface SourceProcessor {
    String getSourceFileExtension();
    void process(String filePath, String sourceFolder, List<String> sourceFolders, Project taskProject);
    void displayMessage(DisplayType type, int count);
}

Project taskProject = getProject();
SourceProcessor processor = new AidlProcessor(); // Create instance of specific processor
String extension = processor.getSourceFileExtension();

// build a list of all the source folders
ArrayList<String> sourceFolders = new ArrayList<String>();

// gather all the source files from all the source folders.
Map<String, String> sourceFiles = getFilesByNameEntryFilter(sourceFolders, "**/*." + extension);
if (sourceFiles.size() > 0) {
    processor.displayMessage(DisplayType.FOUND, sourceFiles.size());
}
// The gen folder may contain other dependency files not generated by this particular
// processor.
// We only care if the first pre-rep is of the right extension.
for (String sourceFilePath : sourceFiles.keySet()) {
    if (sourceFilePath.toLowerCase(Locale.US).endsWith("." + extension)) {
        // remove from the list of sourceFiles to mark as "processed" (but not compiled yet, that'll be done by adding it to toCompile)
        String sourceFolder = sourceFiles.get(sourceFilePath);
        // Process file logic here
    }
}

/**
* @param filter the filter for the files. Typically a glob.
* @return a map of (file, folder)
*/
private Map<String, String> getFilesByNameEntryFilter(List<String> folders, String filter) {
    Map<String, String> sourceFiles = new HashMap<String, String>();

    for (String folder : folders) {
        Iterator<?> iterator = getFilesByNameEntryFilter(folder, filter);

        while (iterator.hasNext()) {
            sourceFiles.put(iterator.next().toString(), folder);
        }
    }
    return sourceFiles;
}

/**
* @param filter the filter for the files. Typically a glob.
* @return an iterator.
*/
private Iterator<?> getFilesByNameEntryFilter(String folder, String filter) {
    Project taskProject = getProject();

    // create a fileset to find all the files in the folder
    FileSet fs = new FileSet();
    fs.setProject(taskProject);
    fs.setDir(new File(folder));
    NameEntry include = fs.createInclude();
    include.setName(filter);

    // loop through the results of the file set
    return fs.iterator();
}

//<End of snippet n. 1>

//<Beginning of snippet n. 2>

package com.android.ant;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecTask;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
* Task to execute renderscript.
*/
public class RenderScriptTask extends MultiFilesTask {

    private String mExecutable;
    private Path mIncludePath;
    private String mGenFolder;

    @Override
    public String getSourceFileExtension() {
        return "rs";
    }

    @Override
    public void process(String filePath, String sourceFolder, List<String> sourceFolders, Project taskProject) {
        // Process logic for RenderScript files
    }

    @Override
    public void displayMessage(DisplayType type, int count) {
        // Display message logic
    }
}

//<End of snippet n. 2>

//<Beginning of snippet n. 3>

public static final String EXT_AIDL = "aidl"; //$NON-NLS-1$
public static final String EXT_RS = "rs"; //$NON-NLS-1$
public static final String EXT_DEP = "d"; //$NON-NLS-1$
public static final String EXT_FS = "fs"; //$NON-NLS-1$ // Added Filterscript extension
public static final String DOT_AIDL = "." + EXT_AIDL; //$NON-NLS-1$
public static final String DOT_RS = "." + EXT_RS; //$NON-NLS-1$
public static final String DOT_DEP = "." + EXT_DEP; //$NON-NLS-1$
public static final String DOT_FS = "." + EXT_FS; //$NON-NLS-1$ // Added Filterscript dot extension

//<End of snippet n. 3>

//<Beginning of snippet n. 4>

import static com.android.SdkConstants.DOT_DEP;
import static com.android.SdkConstants.DOT_JAVA;
import static com.android.SdkConstants.DOT_RS;
import static com.android.SdkConstants.DOT_FS; // Added Filterscript dot reference

import com.android.SdkConstants;
import com.android.ide.eclipse.adt.internal.build.builders.PostCompilerBuilder;

public final static String RE_AIDL_EXT = "\\" + DOT_AIDL + "$"; //$NON-NLS-1$ //$NON-NLS-2$
public final static String RE_RS_EXT = "\\" + DOT_RS + "$"; //$NON-NLS-1$ //$NON-NLS-2$
public final static String RE_DEP_EXT = "\\" + DOT_DEP + "$"; //$NON-NLS-1$ //$NON-NLS-2$
public final static String RE_FS_EXT = "\\" + DOT_FS + "$"; //$NON-NLS-1$ //$NON-NLS-2$ // Added Filterscript regex

//<End of snippet n. 4>

//<Beginning of snippet n. 5>

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

private static Pattern sAidlPattern1 = Pattern.compile("^(.+?):(\\d+):?\\s(.+)$"); //$NON-NLS-1$
private static Pattern sFilterscriptPattern = Pattern.compile("^(.+?)\\.fs$"); //$NON-NLS-1$ // Added Filterscript pattern

private enum AidlType {
    UNKNOWN, INTERFACE, PARCELABLE;
}

@Override
protected String getExtension() {
    return SdkConstants.EXT_AIDL;
}

//<End of snippet n. 5>

//<Beginning of snippet n. 6>

import com.android.ide.eclipse.adt.internal.sdk.Sdk;
import com.android.resources.ResourceFolderType;
import com.android.sdklib.IAndroidTarget;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

private static Pattern sLlvmPattern1 = Pattern.compile("^(.+?):(\\d+):(\\d+):\\s(.+)$"); //$NON-NLS-1$

private static class RsChangeHandler extends SourceChangeHandler {

    @Override
    public void handleSourceFile(IFile file, int kind) {
        // process file handle logic
    }

    @Override
    protected String getExtension() {
        return SdkConstants.EXT_RS;
    }
}

//<End of snippet n. 6>

//<Beginning of snippet n. 7>

public void handleSourceFile(IFile file, int kind) {
    // first the file itself if this is a match for the processor's extension
    if (mProcessor.getExtension().equals(file.getFileExtension())) {
        if (kind == IResourceDelta.REMOVED) {
            mRemoved.add(file);
        } else {
            // remaining logic for processing files
        }
    }
}

//<End of snippet n. 7>

//<Beginning of snippet n. 8>

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
* Returns the extension of the source files handled by this processor.
* @return 
*/
protected abstract String getExtension();

protected abstract String getSavePropertyName();

// if this a file, check that the file actually exists
// and that it's the type of file that's used in this processor
if (r.exists() && getExtension().equalsIgnoreCase(r.getFileExtension())) {
    mFiles.put((IFile) r, new SourceFileData((IFile) r));
}
break;

//<End of snippet n. 8>