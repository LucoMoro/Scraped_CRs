
//<Beginning of snippet n. 0>



package com.android.ant;

import com.android.SdkConstants;
import com.android.sdklib.io.FileOp;

import org.apache.tools.ant.BuildException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

/**
* Task to execute aidl.
private class AidlProcessor implements SourceProcessor {

@Override
        public Set<String> getSourceFileExtensions() {
            return Collections.singleton(SdkConstants.EXT_AIDL);
}

@Override

//<End of snippet n. 0>










//<Beginning of snippet n. 1>


}

interface SourceProcessor {
        Set<String> getSourceFileExtensions();
void process(String filePath, String sourceFolder,
List<String> sourceFolders, Project taskProject);
void displayMessage(DisplayType type, int count);

Project taskProject = getProject();

        Set<String> extensions = processor.getSourceFileExtensions();

// build a list of all the source folders
ArrayList<String> sourceFolders = new ArrayList<String>();
}
}

        ArrayList<String> includePatterns = new ArrayList<String>(extensions.size());
        for (String extension : extensions) {
            includePatterns.add("**/*." + extension);
        }

// gather all the source files from all the source folders.
Map<String, String> sourceFiles = getFilesByNameEntryFilter(sourceFolders,
                includePatterns.toArray(new String[includePatterns.size()]));
if (sourceFiles.size() > 0) {
processor.displayMessage(DisplayType.FOUND, sourceFiles.size());
}
// The gen folder may contain other dependency files not generated by this particular
// processor.
// We only care if the first pre-rep is of the right extension.
            String fileExtension = sourceFilePath.substring(sourceFilePath.lastIndexOf('.') + 1);
            if (extensions.contains(fileExtension.toLowerCase(Locale.US))) {
// remove from the list of sourceFiles to mark as "processed" (but not compiled
// yet, that'll be done by adding it to toCompile)
String sourceFolder = sourceFiles.get(sourceFilePath);
* @param filter the filter for the files. Typically a glob.
* @return a map of (file, folder)
*/
    private Map<String, String> getFilesByNameEntryFilter(List<String> folders, String[] filters) {
Map<String, String> sourceFiles = new HashMap<String, String>();

for (String folder : folders) {
            Iterator<?> iterator = getFilesByNameEntryFilter(folder, filters);

while (iterator.hasNext()) {
sourceFiles.put(iterator.next().toString(), folder);
* @param filter the filter for the files. Typically a glob.
* @return an iterator.
*/
    private Iterator<?> getFilesByNameEntryFilter(String folder, String... filters) {
Project taskProject = getProject();

// create a fileset to find all the files in the folder
FileSet fs = new FileSet();
fs.setProject(taskProject);
fs.setDir(new File(folder));
        for (String filter : filters) {
            NameEntry include = fs.createInclude();
            include.setName(filter);
        }

// loop through the results of the file set
return fs.iterator();

//<End of snippet n. 1>










//<Beginning of snippet n. 2>



package com.android.ant;

import com.android.SdkConstants;
import com.google.common.collect.Sets;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.ExecTask;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
* Task to execute renderscript.
*/
public class RenderScriptTask extends MultiFilesTask {

    private final static Set<String> EXTENSIONS = Sets.newHashSetWithExpectedSize(2);
    static {
        EXTENSIONS.add(SdkConstants.EXT_RS);
        EXTENSIONS.add(SdkConstants.EXT_FS);
    }

private String mExecutable;
private Path mIncludePath;
private String mGenFolder;
}

@Override
        public Set<String> getSourceFileExtensions() {
            return EXTENSIONS;
}

@Override

//<End of snippet n. 2>










//<Beginning of snippet n. 3>


public static final String EXT_AIDL = "aidl"; //$NON-NLS-1$
/** Extension of Renderscript files, i.e. "rs" */
public static final String EXT_RS = "rs"; //$NON-NLS-1$
    /** Extension of FilterScript files, i.e. "fs" */
    public static final String EXT_FS = "fs"; //$NON-NLS-1$
/** Extension of dependency files, i.e. "d" */
public static final String EXT_DEP = "d"; //$NON-NLS-1$
/** Extension of native libraries, i.e. "so" */
public static final String DOT_AIDL = DOT + EXT_AIDL;
/** Dot-Extension of renderscript files, i.e. ".rs" */
public static final String DOT_RS = DOT + EXT_RS;
    /** Dot-Extension of FilterScript files, i.e. ".fs" */
    public static final String DOT_FS = DOT + EXT_FS;
/** Dot-Extension of dependency files, i.e. ".d" */
public static final String DOT_DEP = DOT + EXT_DEP;
/** Dot-Extension of dex files, i.e. ".dex" */

//<End of snippet n. 3>










//<Beginning of snippet n. 4>


import static com.android.SdkConstants.DOT_DEP;
import static com.android.SdkConstants.DOT_JAVA;
import static com.android.SdkConstants.DOT_RS;
import static com.android.SdkConstants.DOT_FS;

import com.android.SdkConstants;
import com.android.ide.eclipse.adt.internal.build.builders.PostCompilerBuilder;
public final static String RE_AIDL_EXT = "\\" + DOT_AIDL + "$"; //$NON-NLS-1$ //$NON-NLS-2$
/** Regexp for rs extension, i.e. "\.rs$" */
public final static String RE_RS_EXT = "\\" + DOT_RS + "$"; //$NON-NLS-1$ //$NON-NLS-2$
    /** Regexp for rs extension, i.e. "\.fs$" */
    public final static String RE_FS_EXT = "\\" + DOT_FS + "$"; //$NON-NLS-1$ //$NON-NLS-2$
/** Regexp for .d extension, i.e. "\.d$" */
public final static String RE_DEP_EXT = "\\" + DOT_DEP + "$"; //$NON-NLS-1$ //$NON-NLS-2$


//<End of snippet n. 4>










//<Beginning of snippet n. 5>


import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

*/
private static Pattern sAidlPattern1 = Pattern.compile("^(.+?):(\\d+):?\\s(.+)$"); //$NON-NLS-1$

    private final static Set<String> EXTENSIONS = Collections.singleton(SdkConstants.EXT_AIDL);

private enum AidlType {
UNKNOWN, INTERFACE, PARCELABLE;
}

@Override
    protected Set<String> getExtensions() {
        return EXTENSIONS;
}

@Override

//<End of snippet n. 5>










//<Beginning of snippet n. 6>


import com.android.ide.eclipse.adt.internal.sdk.Sdk;
import com.android.resources.ResourceFolderType;
import com.android.sdklib.IAndroidTarget;
import com.google.common.collect.Sets;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

*/
private static Pattern sLlvmPattern1 = Pattern.compile("^(.+?):(\\d+):(\\d+):\\s(.+)$"); //$NON-NLS-1$

    private final static Set<String> EXTENSIONS = Sets.newHashSetWithExpectedSize(2);
    static {
        EXTENSIONS.add(SdkConstants.EXT_RS);
        EXTENSIONS.add(SdkConstants.EXT_FS);
    }

private static class RsChangeHandler extends SourceChangeHandler {

@Override
// remove the file name segment
relative = relative.removeLastSegments(1);
// add the file name of a Renderscript file.
                relative = relative.append(file.getName().replaceAll(
                        AdtConstants.RE_DEP_EXT, SdkConstants.DOT_RS));

                if (!findInSourceFolders(processor, genFolder, relative)) {
                    // could be a FilterScript file?
                    relative = file.getFullPath().makeRelativeTo(genFolder.getFullPath());
                    // remove the file name segment
                    relative = relative.removeLastSegments(1);
                    // add the file name of a FilterScript file.
                    relative = relative.append(file.getName().replaceAll(
                            AdtConstants.RE_DEP_EXT, SdkConstants.DOT_FS));

                    return findInSourceFolders(processor, genFolder, relative);
                }

                return true;
            }

            return r;
        }

        private boolean findInSourceFolders(SourceProcessor processor, IFolder genFolder,
                IPath relative) {
            // now look for a match in the source folders.
            List<IPath> sourceFolders = BaseProjectHelper.getSourceClasspaths(
                    processor.getJavaProject());
            IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();

            for (IPath sourceFolderPath : sourceFolders) {
                IFolder sourceFolder = root.getFolder(sourceFolderPath);
                // we don't look in the 'gen' source folder as there will be no source in there.
                if (sourceFolder.exists() && sourceFolder.equals(genFolder) == false) {
                    IFile sourceFile = sourceFolder.getFile(relative);
                    SourceFileData data = processor.getFileData(sourceFile);
                    if (data != null) {
                        addFileToCompile(sourceFile);
                        return true;
}
}
}

            return false;
}

@Override
}

@Override
    protected Set<String> getExtensions() {
        return EXTENSIONS;
}

@Override

//<End of snippet n. 6>










//<Beginning of snippet n. 7>



public void handleSourceFile(IFile file, int kind) {
// first the file itself if this is a match for the processor's extension
        if (mProcessor.getExtensions().contains(file.getFileExtension())) {
if (kind == IResourceDelta.REMOVED) {
mRemoved.add(file);
} else {

//<End of snippet n. 7>










//<Beginning of snippet n. 8>


import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

* Returns the extension of the source files handled by this processor.
* @return
*/
    protected abstract Set<String> getExtensions();

protected abstract String getSavePropertyName();

// if this a file, check that the file actually exist
// and that it's the type of of file that's used in this processor
if (r.exists() &&
                               getExtensions().contains(
                                       r.getFileExtension().toLowerCase(Locale.US))) {
mFiles.put((IFile) r, new SourceFileData((IFile) r));
}
break;

//<End of snippet n. 8>








